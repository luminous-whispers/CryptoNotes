ç”± äºçˆå°‰-21371048 ç¼–å†™, æ”¯æŒéƒ¨åˆ†å›½å¯†ç®—æ³•ğŸš€ä¸å¸¸è§åŠ å¯†æ–¹æ¡ˆ. 

- å¸¸è§å¯†ç æ•°å­¦å‡½æ•°
- åˆ†ç»„å¯†ç 
- å…¬é’¥åŠ å¯†
- æ•°å­—ç­¾å
- è¿­ä»£å‹å“ˆå¸Œç®—æ³•

æœ¬åº“æ”¯æŒå¤šç§è°ƒç”¨æ–¹å¼, å¯æ‰©å±•æ€§å¼º.

# 1 ç»„ä»¶ä»‹ç»
### 1.1 æ•°å­¦ä¸ç¼–ç 

- æ•°æ®ç±»å‹è½¬åŒ–, æ‰“åŒ…è§£åŒ…
- æœ‰é™åŸŸè¿ç®—
- ä¼½ç½—ååŸŸè¿ç®—
- ç´ æ•°ç›¸å…³è¿ç®—
- æ¤­åœ†æ›²çº¿åŸŸè¿ç®—

### 1.2 åˆ†ç»„å¯†ç 

- AES, é¢å‘å¯¹è±¡å®ç°
- DES, é¢å‘å¯¹è±¡å®ç°
- SM4, é¢å‘å¯¹è±¡å®ç°
- å·¥ä½œæ¨¡å¼åŠå¤šç§å¡«å……

### 1.3 å…¬é’¥åŠ å¯†åŠæ•°å­—ç­¾å

- RSA-OAEPåŠ è§£å¯†, ä¸RSA-PSSæ•°å­—ç­¾å
- ECC-ElGamal, é¢å‘å¯¹è±¡å®ç°. æ¥å£æœªç»Ÿä¸€.
- SM2, æ¥å£æœªç»Ÿä¸€

### 1.4 å“ˆå¸Œå‡½æ•°

- SHA1, é¢å‘å¯¹è±¡å®ç°
- SM3, é¢å‘å¯¹è±¡å®ç°

# 2 ä½¿ç”¨è¯´æ˜

æ‰€æœ‰å¯†ç ç®—æ³•å¤„ç†çš„æ•°æ®ç±»å‹éƒ½æ˜¯ `bstr` å­—èŠ‚ä¸²ç±»å‹, åŠ å¯†æ–‡ä»¶å¯ä»¥ç”¨äºŒè¿›åˆ¶å½¢å¼å°†æ–‡ä»¶æ‰“å¼€, åŠ å¯†æ•°æ®æµç”¨å­—èŠ‚æµå½¢å¼è¯»å…¥å³å¯, å…¼å®¹æ€§å¥½.

## 2.1 åˆ†ç»„å¯†ç 

å¯¹ç§°åŠ å¯†çˆ¶ç±»:
```python
class SymmetricCryptor(object):
    '''å¯¹ç§°åŠ å¯†å™¨'''
    def __init__(self, k):
	    '''åˆå§‹åŒ–å¯†é’¥, å¹¶æ£€æŸ¥å¯†é’¥æ˜¯å¦åˆæ³•'''
        self.k = key_init(k)
        self.blocksize = None
        self.name = None
    
    def __call__(self, k=None):
	    '''æ›´æ–°å¯†é’¥, å¹¶æ£€æŸ¥å¯†é’¥æ˜¯å¦åˆæ³•'''
        if k is not None:
            self.k = key_init(k)
        return self

    def encrypt(self, data
				    , padding_mode='pkcs7'
				    , link_mode: LinkMode=None
				    )->bytes:
        '''å®Œæˆæ•°æ®å¡«å……ï¼Œå¹¶å¯¹æ•°æ®è¿›è¡ŒåŠ å¯†
        :data: åŸå§‹å¾…åŠ å¯†æ•°æ®
        :padding_mode: é»˜è®¤ä½¿ç”¨pkcs#7æ ‡å‡†å¡«å……æ•°æ®
        :link_mode: é“¾æ¥æ¨¡å¼, é»˜è®¤ä¸å¼€å¯. æ•°æ®é•¿åº¦è¶…è¿‡å•ç»„é•¿åº¦æ—¶, å¼ºåˆ¶å¯åŠ¨CBCæ¨¡å¼'''
        if padding_mode == None:
            # æ˜¾å¼æŒ‡å®šä¸å¡«å……, æ£€æŸ¥æ•°æ®æ ¼å¼åˆæ³•
            ...
        else:
            # å¡«å……æ•°æ®
            data = pad(data, self.block_size, padding_mode)

        if link_mode is not None:
            # æ˜¾å¼æŒ‡å®šä½¿ç”¨é“¾æ¥æ¨¡å¼
            link_mode.encrypt(data, self.block_size, self.encrypt_block)
            return self.link_mode_process(data, Act.ENCRYPT, link_mode=link_mode) 
        elif len(data) > self.block_size:
            # æœªæ˜¾ç¤ºæŒ‡å®šé“¾æ¥æ¨¡å¼ï¼Œä½†æ•°æ®é•¿åº¦è¶…è¿‡åŠ å¯†å—é•¿åº¦ï¼Œå¿…é¡»ä½¿ç”¨é“¾æ¥æ¨¡å¼
            my_cbc = CBC(iv=b'\x00'*self.block_size)
            return my_cbc.encrypt(data, self.block_size, self.encrypt_block)
        else:
            '''å®Œæˆ*å•ç»„*å¯¹ç§°åŠ å¯†'''
            self.encrypt_block(data)


    def decrypt(self, data
				    , padding_mode='pkcs7'
				    , link_mode: LinkMode=None
				    )->bytes:
	    '''è§£å¯†æ•°æ®, å¹¶å»å¡«å……'''
		...
	def encrypt_block(self, data):
		'''å•ç»„åŠ å¯†'''
		...
	def decrypt_block(self, data):
		'''å•ç»„è§£å¯†'''
		...


class LinkMode:
	'''é“¾æ¥æ¨¡å¼, æ”¯æŒcbc, ecb, ctr, ofb, cfb, éƒ½æ˜¯ç®€æ˜“ç‰ˆ.'''
    def __init__(self, iv: bytes=None) -> None:
        self.iv = iv
        self.name = 'detailed mode'
    
    def encrypt(self, data, bl ock_size, funct):
        '''
        é“¾æ¥æ¨¡å¼åŠ å¯†
        :data: data to encrypt
        :block_size: encrypted block size
        :funct: SymmetricCryptor ç±»çš„ en(de)crypt_block å¤„ç†å•æ•°æ®å—å®ä¾‹æ–¹æ³•
        '''
        ...
        
    def decrypt(self, data, block_size, funct):
        ...
        
```

è¾“å…¥è¾“å‡ºæ•°æ®çš„æ ¼å¼ä¸º**äºŒè¿›åˆ¶ä¸² `bstr`**:
- é»˜è®¤ä½¿ç”¨ `pkcs#7` å¯¹æ•°æ®è¿›è¡Œ**å¡«å……**.
- è‹¥å¡«å……åé•¿åº¦è¶…è¿‡å…è®¸é•¿åº¦, é»˜è®¤ä½¿ç”¨ **`CBC` é“¾æ¥æ¨¡å¼**

æ”¯æŒ**å¯¹ç§°åŠ å¯†ç®—æ³•**:
- DES, EDE
- SM4
- AES128, AES192, AES256

æ”¯æŒ**é“¾æ¥æ¨¡å¼**:
- ECB
- CBC
- CFB, OFB, CTR: å®ç°äº†ç®€æ˜“ç‰ˆæœ¬, ä½†æ²¡è°ƒæ¥å£

æ”¯æŒ**å¡«å……**æ–¹å¼:
- PKCS#7: å¡«å…… `padding_len`, `padding_len` ä¸º1å­—èŠ‚è¡¨ç¤ºçš„å¡«å……é•¿åº¦
- ANSI X.923: å¡«å……è‹¥å¹² `b'\x00'` + `padding_len`
- ISO 7816-4: å¡«å…… `b'\x10'` + è‹¥å¹² `b'\x00'`

### 2.2.1 ç”¨ä¾‹
æ›´æ–°å¯†é’¥æ—¶, å‡½æ•°å¼è°ƒç”¨
```python
# åˆå§‹åŒ–å¯†é’¥
my_des = DES(k1)

# æ›´æ–°å¯†é’¥
my_des(k2)
```

é€šè¿‡åŠ è§£å¯†æ–¹æ³•, è¾“å…¥å¾…å¤„ç†æ•°æ®.
```python
# åŠ å¯†/è§£å¯†
my_des.encrypt(data)

# æ›´æ–°å¯†é’¥åŒæ—¶åŠ è§£å¯†
my_des(k3).encrypt(data)
```

æ”¯æŒé“¾æ¥æ¨¡å¼åŠå¤šç§å¡«å……æ–¹å¼: 
```python
# ä¸åŒå¡«å……æ–¹å¼
my_des.encrypt(data, padding_mode='x923')

# ä¸åŒé“¾æ¥æ–¹å¼
my_des.decrypt(data, link_mode=CBC(iv))

my_des.encrypt(data, padding_mode='iso7816', link_mode=ECB())
```

æ›´å¤šæµ‹è¯•æ ·ä¾‹, è§`tests/test_cipher/test_des.py`:
```python
# è‡ªåŠ¨pkck#7å¡«å……
print(my_des.encrypt(b'1234', 
                     padding_mode= 'pkcs7'
                     ).hex())

# åŠ è§£å¯†æ–‡ä»¶
file_path = 'my_module\\crypto_yjw\\tests\\test_cipher\\test_aes.py'
with open(file_path, 'rb') as f:
    data = f.read()
    cipher = my_des.encrypt(data) # é»˜è®¤CBCæ¨¡å¼
    print('æ–‡ä»¶åŠ å¯†å†…å®¹: ', cipher.hex())

    # æ–‡ä»¶è§£å¯†
    restore_data = my_des.decrypt(cipher)
    print('æ¢å¤å‡ºçš„æ•°æ®ï¼š', restore_data)

    # æµ‹è¯•ECBå·¥ä½œæ¨¡å¼
    cipher_ECB = my_des.encrypt(data, link_mode=ECB(iv=None))
    print('ECB test: ', cipher_ECB.hex())

# æµ‹è¯•å¡«å……
print('padding test: ', my_des.encrypt(b'1234',padding_mode='x923').hex())
```

### 2.2.2 æ³¨æ„äº‹é¡¹

å¯†é’¥è¦æ±‚:
- ç¬¦åˆå¯¹åº”ç®—æ³•é•¿åº¦è¦æ±‚.
- ANSIç¼–ç çš„å¯è§å­—ç¬¦ `32-126`, å­—èŠ‚ä¸²å½¢å¼.

## 2.2 å“ˆå¸Œå‡½æ•°

è¿­ä»£å‹å“ˆå¸Œå‡½æ•°çˆ¶ç±»
```python
class IterativeHasher:

    def __init__(self, msg:bytes=None):
	    '''åˆå§‹åŒ–å“ˆå¸Œå‡½æ•°, å¹¶å¤„ç†å·²æœ‰æ•°æ®'''
        self.digest_size: ByteLength = None # å“ˆå¸Œå€¼é•¿åº¦
        self.block_size: ByteLength = None # æ•°æ®å—é•¿åº¦
        self.name: str = None # hasheråç§°

        self._state = [...] # è¿­ä»£å‹å“ˆå¸Œå†…éƒ¨çŠ¶æ€, åˆå§‹åŒ–ä¸ºIV
        self._msg_len: ByteLength = 0 # å·²ä¼ å…¥æ¶ˆæ¯é•¿åº¦
        self._buffer = b''
        if msg is not None:
            self.update(msg)

    def update(self, msg: bytes):
        '''æ›´æ–°bufferï¼Œå¹¶å¤„ç†å·²ç­‰äºæ•°æ®å—é•¿åº¦çš„æ•°æ®'''
        self._buffer += msg
        self._msg_len += len(msg)
        while len(self._buffer) >= self.block_size:
            # è¿­ä»£ä¸€æ¬¡, å¤„ç†å—ï¼Œå¹¶æ›´æ–°stateä¸buffer
            self._round_f(self._buffer[:64])
            self._buffer = self._buffer[64:]

    def digest(self)->bytes:
        '''å¡«å……ï¼Œå¹¶å¤„ç†å‰©ä½™buffer'''
        msg = self._padding(self._buffer) # å¡«å……è‡³64æ•´æ•°å€
        while len(msg) > 0:
            # å¤„ç†å—ï¼Œå¹¶æ›´æ–°state
            self._round_f(msg[:64])
            msg = msg[64:]
            
		... # è¾“å‡ºstate
    
    def hexdigest(self)->str:
        '''è¿”å›åå…­è¿›åˆ¶å­—ç¬¦ä¸²å½¢å¼digest'''
        return self.digest().hex()
		
	def _round_f(self, data: bytes):
		'''å•è½®è¿­ä»£å‡½æ•°, æ›´æ–°state'''
		...

	def copy(self):
	'''å¤åˆ¶Hasher, æœ‰ç›¸åŒå†…éƒ¨çŠ¶æ€, ç”¨äºåˆ†æ”¯å“ˆå¸Œ'''
		...
```

åˆå§‹åŒ–å“ˆå¸Œå‡½æ•°å, ä½¿ç”¨`update`å‘å…¶ä¸­ç»§ç»­æ·»åŠ å¾…å“ˆå¸Œæ¶ˆæ¯.   
æ¶ˆæ¯åœ¨å“ˆå¸Œå‡½æ•°å†…éƒ¨ä¼šè¢«é¢„å¤„ç†, ä½¿ç”¨`digest`æ–¹æ³•è¾“å‡ºæœ€ç»ˆç»“æœ.

æ”¯æŒ**å“ˆå¸Œç®—æ³•**:
- SHA1: ç¬¬ä¸€ä»£å®‰å…¨å“ˆå¸Œå‡½æ•°
- SM3: å›½å¯†sm3æ‚å‡‘ç®—æ³•

### 2.4.1 ç”¨ä¾‹

```python
# åˆå§‹åŒ–
my_hasher = SHA1(msg)
my_hasher.update(fllow_up_msg) # æ·»åŠ åç»­æ•°æ® 

hash_value: bytes = my_hasher.digest() # è¾“å‡ºå­—èŠ‚ä¸²æ‘˜è¦å€¼
hash_hex_value: str = my_hasher.hexdigest() # 16è¿›åˆ¶ä¸²å½¢å¼

# æ¸…é™¤å†…éƒ¨å·²æœ‰ç¼“å­˜æ•°æ®, ç›¸å½“äºæ–°å»ºä¸€ä¸ªhasher. æ”¯æŒé“¾å¼è°ƒç”¨.
new_digest = my_hasher.new( new_msg ).digest()
```

æ›´å¤šæµ‹è¯•æ ·ä¾‹:
```python
#  åˆ›å»ºæ–‡ä»¶hash
file_path = 'my_module\\crypto_yjw\\tests\\test_cipher\\test_aes.py'
with open(file_path, 'rb') as f:
    data = f.read()
    my_sha1 = SHA1(data)
    print(my_sha1.digest())
    print(my_sha1.hexdigest())

# ojæ ·ä¾‹
new_my_sha1 = SHA1(b'this is the first SHA-1 test.')
print(new_my_sha1.hexdigest())

# è¾¹ç•Œæ•°æ®æµ‹è¯•
NoneThing = my_sha1 = my_sha1.new(b'').hexdigest()
print(NoneThing)
```

## 2.3 å…¬é’¥å¯†ç åŠæ•°å­—ç­¾å

æ­¤éƒ¨åˆ†é‡ç‚¹å®ç°äº†RSAç›¸å…³çš„å…¬é’¥å¯†ç ç®—æ³•, åŸºäºåŸºç¡€RSA, é¢å‘å¯¹è±¡å®ç°äº†RSAå¯†é’¥ç”Ÿæˆ, RSA-OAEPå¡«å……åŠ è§£å¯†, ä¸RSA-PSSç­¾åç®—æ³•.

å¦å¤–, ä¹Ÿç»™å‡ºäº†Elgamalå’ŒSM2ç›¸å…³é¢å‘å¯¹è±¡, ä½†æ˜¯æ¥å£æ²¡æœ‰æŒ‰ç…§`__init__.py`ä¸­å£°æ˜çš„æ¥, æ²¡æ¥å¾—åŠæ”¹.
```python
class PublicKeyCryptor:
    '''éå¯¹ç§°å¯†ç ä½“åˆ¶'''
    def __init__(self, keys: List[Any]=None):
        self.name = 'detailed algorithm'
        self.key_size: BitLen = 512 # å®‰å…¨å‚æ•°
        self.keys = keys

    def __call__(self, keys: List[Any]=None):
        '''æ›´æ–°å¯†é’¥'''
        if keys is not None:
            self.pk, self.sk = keys
        return self

    def key_gen(self, key_size):
	    '''å¯†é’¥ç”Ÿæˆ'''
        pk = None
        sk = None
        return pk, sk

    def encrypt(self, data: bytes):
        pass

    def decrypt(self, data: bytes):
        pass

    def sign(self, data: bytes):
        pass

    def verify(self, data:bytes):
        pass
```

#### 2.3.1 ç”¨ä¾‹:

æµ‹è¯•è¯¦è§ `./tests/test_public_key/test_rsa.py`.

```python
keys = RSA.key_gen(1024) # ç”Ÿæˆå¯†é’¥éœ€è¦å‡ åˆ†é’Ÿæ—¶é—´, å› ä¸ºè¦é€‰å–å®‰å…¨ç´ æ•°
my_rsa = RSA(keys)

# ä¸€èˆ¬åŠ è§£å¯†
cipher = my_rsa.encrypt(data)
restored_msg = my_ras.decrypt(cipher)

# æµ‹è¯• RSA-OAEPå¡«å……åè®® åŠ è§£å¯†
cipher= my_rsa.encrypt(data, 
					   padding=OAEP(
									mgf = MGF1( SHA1()),
									hasher = SHA1(), 
									label = None))

# OAEPæ˜¯å¡«å……ç±», è¿™é‡Œå£°æ˜ä¸€ä¸ªå®ä¾‹ä¼ å…¥

# æµ‹è¯• RSA-PSSåè®® æ•°å­—ç­¾å
my_pss_rsa = PSS_RSA(keys, hasher = SHA1(), mgf = MGF1(SHA1()))
s = my_pss_rsa.sign(data)
```