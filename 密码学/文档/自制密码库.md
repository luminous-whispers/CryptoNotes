æœ¬å¯†ç åº“ç”± äºçˆå°‰-21371048 ç¼–å†™, æ”¯æŒéƒ¨åˆ†å›½å¯†ç®—æ³•ğŸš€ä¸å¸¸è§åŠ å¯†æ–¹æ¡ˆ. 

- å¸¸è§å¯†ç æ•°å­¦å‡½æ•°
- åˆ†ç»„å¯†ç 
- å…¬é’¥åŠ å¯†
- æ•°å­—ç­¾å
- è¿­ä»£å‹å“ˆå¸Œç®—æ³•

æœ¬åº“æ”¯æŒå¤šç§è°ƒç”¨æ–¹å¼, åŒæ ·æ”¯æŒå‘½ä»¤è¡Œæ“ä½œä¸æ–‡ä»¶æ“ä½œ.

# 1 ç»„ä»¶ä»‹ç»
## 1.1 æ•°å­¦ä¸ç¼–ç 

- æ–‡ä»¶æ“ä½œ
- :obs_checkmark: ç¼–ç 
- :obs_checkmark: åˆ†ç»„å¡«å……

æ•°å­¦ç»„ä»¶:

- å®‰å…¨ç´ æ•°é€‰å–
- éšæœºæ•°
- :obs_checkmark: ç±»å‹è½¬åŒ–
- :luc_check: æœ‰é™åŸŸè¿ç®—
- :luc_check: æ•°è®ºæ“ä½œ
- :obs_checkmark: æ¤­åœ†æ›²çº¿åŸŸè¿ç®—

## 1.2 åˆ†ç»„å¯†ç 

- :obs_checkmark: SM4 OOå®ç°
- :obs_checkmark: AES OOå®ç°, æ¥å£æœªç»Ÿä¸€
- :obs_checkmark: DES OOå®ç°, æ¥å£æœªç»Ÿä¸€
- å„ç®—æ³•åˆè§„å¼ºå¯†é’¥ç”Ÿæˆ
- :obs_checkmark: å·¥ä½œæ¨¡å¼åŠå¡«å……
- æ”¯æŒæ–‡ä»¶æ“ä½œ
- è¾¹ç•Œæ£€æµ‹: å¯†é’¥å’Œæ•°æ®åˆè§„æ€§æ£€æµ‹

## 1.3 å…¬é’¥åŠ å¯†åŠæ•°å­—ç­¾å

- RSA OOå®ç°, æ¥å£ç»Ÿä¸€, æ•°å­—ç­¾å
- ElGamal OOå®ç°, æ¥å£ç»Ÿä¸€, æ•°å­—ç­¾å
- ECC-ElGamal OOå®ç°, æ¥å£ç»Ÿä¸€, æ•°å­—ç­¾å
- ECC-SM2 OOå®ç°, æ¥å£ç»Ÿä¸€, æ•°å­—ç­¾å
- è¾“å…¥æ£€æµ‹, æµ‹è¯•æ•°æ®

## 1.4 å“ˆå¸Œå‡½æ•°

- :obs_checkmark: SHA1 OOå®ç°
- :obs_checkmark: SM3 OOå®ç°
- è¾“å…¥æ£€æµ‹

# 2 ä½¿ç”¨è¯´æ˜

## 2.1 æ•°å­¦ç»„ä»¶

## 2.2 åˆ†ç»„å¯†ç 

å¯¹ç§°åŠ å¯†çˆ¶ç±»:
```python
class SymmetricCryptor(object):
    '''å¯¹ç§°åŠ å¯†å™¨'''
    def __init__(self, k):
	    '''åˆå§‹åŒ–å¯†é’¥, å¹¶æ£€æŸ¥å¯†é’¥æ˜¯å¦åˆæ³•'''
        self.k = key_init(k)
        self.blocksize = None
        self.name = None
    
    def __call__(self, k=None):
	    '''æ›´æ–°å¯†é’¥, å¹¶æ£€æŸ¥å¯†é’¥æ˜¯å¦åˆæ³•'''
        if k is not None:
            self.k = key_init(k)
        return self

    def encrypt(self, data
				    , padding_mode='pkcs7'
				    , link_mode: LinkMode=None
				    )->bytes:
        '''å®Œæˆæ•°æ®å¡«å……ï¼Œå¹¶å¯¹æ•°æ®è¿›è¡ŒåŠ å¯†
        :data: åŸå§‹å¾…åŠ å¯†æ•°æ®
        :padding_mode: é»˜è®¤ä½¿ç”¨pkcs#7æ ‡å‡†å¡«å……æ•°æ®
        :link_mode: é“¾æ¥æ¨¡å¼, é»˜è®¤ä¸å¼€å¯. æ•°æ®é•¿åº¦è¶…è¿‡å•ç»„é•¿åº¦æ—¶, å¼ºåˆ¶å¯åŠ¨CBCæ¨¡å¼'''
        if padding_mode == None:
            # æ˜¾å¼æŒ‡å®šä¸å¡«å……, æ£€æŸ¥æ•°æ®æ ¼å¼åˆæ³•
            ...
        else:
            # å¡«å……æ•°æ®
            data = pad(data, self.block_size, padding_mode)

        if link_mode is not None:
            # æ˜¾å¼æŒ‡å®šä½¿ç”¨é“¾æ¥æ¨¡å¼
            link_mode.encrypt(data, self.block_size, self.encrypt_block)
            return self.link_mode_process(data, Act.ENCRYPT, link_mode=link_mode) 
        elif len(data) > self.block_size:
            # æœªæ˜¾ç¤ºæŒ‡å®šé“¾æ¥æ¨¡å¼ï¼Œä½†æ•°æ®é•¿åº¦è¶…è¿‡åŠ å¯†å—é•¿åº¦ï¼Œå¿…é¡»ä½¿ç”¨é“¾æ¥æ¨¡å¼
            my_cbc = CBC(iv=b'\x00'*self.block_size)
            return my_cbc.encrypt(data, self.block_size, self.encrypt_block)
        else:
            '''å®Œæˆ*å•ç»„*å¯¹ç§°åŠ å¯†'''
            self.encrypt_block(data)


    def decrypt(self, data
				    , padding_mode='pkcs7'
				    , link_mode: LinkMode=None
				    )->bytes:
	    '''è§£å¯†æ•°æ®, å¹¶å»å¡«å……'''
		...
	def encrypt_block(self, data):
		'''å•ç»„åŠ å¯†'''
		...
	def decrypt_block(self, data):
		'''å•ç»„è§£å¯†'''
		...


class LinkMode:
	'''é“¾æ¥æ¨¡å¼, æ”¯æŒcbc, ecb, ctr, ofb, cfb, éƒ½æ˜¯ç®€æ˜“ç‰ˆ.'''
    def __init__(self, iv: bytes=None) -> None:
        self.iv = iv
        self.name = 'detailed mode'
    
    def encrypt(self, data, bl ock_size, funct):
        '''
        é“¾æ¥æ¨¡å¼åŠ å¯†
        :data: data to encrypt
        :block_size: encrypted block size
        :funct: SymmetricCryptor ç±»çš„ en(de)crypt_block å¤„ç†å•æ•°æ®å—å®ä¾‹æ–¹æ³•
        '''
        ...
        
    def decrypt(self, data, block_size, funct):
        ...
        
```

è¾“å…¥è¾“å‡ºæ•°æ®çš„æ ¼å¼ä¸º**äºŒè¿›åˆ¶ä¸² `bstr`**:
- é»˜è®¤ä½¿ç”¨ `pkcs#7` å¯¹æ•°æ®è¿›è¡Œ**å¡«å……**.
- è‹¥å¡«å……åé•¿åº¦è¶…è¿‡å…è®¸é•¿åº¦, é»˜è®¤ä½¿ç”¨ **`CBC` é“¾æ¥æ¨¡å¼**

æ”¯æŒ**å¯¹ç§°åŠ å¯†ç®—æ³•**:
- DES, EDE
- SM4
- AES128, AES192, AES256

æ”¯æŒ**é“¾æ¥æ¨¡å¼**:
- ECB
- CBC
- CFB: é»˜è®¤å—å¤§å°æ˜¯æ•°æ®å—å¤§å°çš„æ•´å› å­
- OFB
- CTR: ç®€å•è®¡æ•°å™¨ç‰ˆæœ¬, æœªå¼•å…¥éšæœº

æ”¯æŒ**å¡«å……**æ–¹å¼:
- PKCS#7: å¡«å…… `padding_len`, `padding_len` ä¸º1å­—èŠ‚è¡¨ç¤ºçš„å¡«å……é•¿åº¦
- ANSI X.923: å¡«å……è‹¥å¹² `b'\x00'` + `padding_len`
- ISO 7816-4: å¡«å…… `b'\x10'` + è‹¥å¹² `b'\x00'`

### 2.2.1 ç”¨ä¾‹
æ›´æ–°å¯†é’¥æ—¶, å‡½æ•°å¼è°ƒç”¨
```python
# åˆå§‹åŒ–å¯†é’¥
my_des = DES(k1)

# æ›´æ–°å¯†é’¥
my_des(k2)
```

é€šè¿‡åŠ è§£å¯†æ–¹æ³•, è¾“å…¥å¾…å¤„ç†æ•°æ®.
```python
# åŠ å¯†/è§£å¯†
my_des.encrypt(data)

# æ›´æ–°å¯†é’¥åŒæ—¶åŠ è§£å¯†
my_des(k3).encrypt(data)
```

æ”¯æŒé“¾æ¥æ¨¡å¼åŠå¡«å……æ–¹å¼: 
```python
# ä¸åŒå¡«å……æ–¹å¼
my_des.encrypt(data, padding_mode='x923')

# ä¸åŒé“¾æ¥æ–¹å¼
my_des.decrypt(data, link_mode=CBC(iv))

my_des.encrypt(data, padding_mode='iso7816', link_mode=ECB())
```


### 2.2.2 æ³¨æ„äº‹é¡¹

å¯†é’¥è¦æ±‚:
- ç¬¦åˆå¯¹åº”ç®—æ³•é•¿åº¦è¦æ±‚.
- ANSIç¼–ç çš„å¯è§å­—ç¬¦ `32-126`, å­—èŠ‚ä¸²å½¢å¼.


## 2.3 å…¬é’¥å¯†ç åŠæ•°å­—ç­¾å

## 2.4 å“ˆå¸Œå‡½æ•°

è¿­ä»£å‹å“ˆå¸Œå‡½æ•°çˆ¶ç±»
```python
class IterativeHasher:

    def __init__(self, msg:bytes=None):
	    '''åˆå§‹åŒ–å“ˆå¸Œå‡½æ•°, å¹¶å¤„ç†å·²æœ‰æ•°æ®'''
        self.digest_size: ByteLength = None # å“ˆå¸Œå€¼é•¿åº¦
        self.block_size: ByteLength = None # æ•°æ®å—é•¿åº¦
        self.name: str = None # hasheråç§°

        self._state = [...] # è¿­ä»£å‹å“ˆå¸Œå†…éƒ¨çŠ¶æ€, åˆå§‹åŒ–ä¸ºIV
        self._msg_len: ByteLength = 0 # å·²ä¼ å…¥æ¶ˆæ¯é•¿åº¦
        self._buffer = b''
        if msg is not None:
            self.update(msg)

    def update(self, msg: bytes):
        '''æ›´æ–°bufferï¼Œå¹¶å¤„ç†å·²ç­‰äºæ•°æ®å—é•¿åº¦çš„æ•°æ®'''
        self._buffer += msg
        self._msg_len += len(msg)
        while len(self._buffer) >= self.block_size:
            # è¿­ä»£ä¸€æ¬¡, å¤„ç†å—ï¼Œå¹¶æ›´æ–°stateä¸buffer
            self._round_f(self._buffer[:64])
            self._buffer = self._buffer[64:]

    def digest(self)->bytes:
        '''å¡«å……ï¼Œå¹¶å¤„ç†å‰©ä½™buffer'''
        msg = self._padding(self._buffer) # å¡«å……è‡³64æ•´æ•°å€
        while len(msg) > 0:
            # å¤„ç†å—ï¼Œå¹¶æ›´æ–°state
            self._round_f(msg[:64])
            msg = msg[64:]
            
		... # è¾“å‡ºstate
    
    def hexdigest(self)->str:
        '''è¿”å›åå…­è¿›åˆ¶å­—ç¬¦ä¸²å½¢å¼digest'''
        return self.digest().hex()
		
	def _round_f(self, data: bytes):
		'''å•è½®è¿­ä»£å‡½æ•°, æ›´æ–°state'''
		...

	def copy(self):
	'''å¤åˆ¶Hasher, æœ‰ç›¸åŒå†…éƒ¨çŠ¶æ€, ç”¨äºåˆ†æ”¯å“ˆå¸Œ'''
		...
```

åˆå§‹åŒ–å“ˆå¸Œå‡½æ•°å, ä½¿ç”¨`update`å‘å…¶ä¸­ç»§ç»­æ·»åŠ å¾…å“ˆå¸Œæ¶ˆæ¯.   
æ¶ˆæ¯åœ¨å“ˆå¸Œå‡½æ•°å†…éƒ¨ä¼šè¢«é¢„å¤„ç†, ä½¿ç”¨`digest`æ–¹æ³•è¾“å‡ºæœ€ç»ˆç»“æœ.

æ”¯æŒ**å“ˆå¸Œç®—æ³•**:
- SHA1: ç¬¬ä¸€ä»£å®‰å…¨å“ˆå¸Œå‡½æ•°
- SM3: å›½å¯†sm3æ‚å‡‘ç®—æ³•

### 2.4.1 ç”¨ä¾‹
```python
my_hasher = SHA1(msg) #åˆå§‹åŒ–
my_hasher.update(fllow_up_msg) # æ·»åŠ åç»­æ•°æ® 

hash_value: bytes = my_hasher.digest() # è¾“å‡ºå­—èŠ‚ä¸²æ‘˜è¦å€¼
hash_hex_value: str = my_hasher.digest() # 16è¿›åˆ¶ä¸²å½¢å¼
```

# 3 éƒ¨åˆ†å®ç°ç»†èŠ‚